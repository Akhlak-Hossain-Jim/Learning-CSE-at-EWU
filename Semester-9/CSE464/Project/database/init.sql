
-- Housekeeping
DROP VIEW IF EXISTS v_order_latest_status;
DROP TABLE IF EXISTS customers, products, orders, order_items, payments, audit_products, audit_orders, audit_order_items, audit_payments CASCADE;
DROP SEQUENCE IF EXISTS seq_audit_products, seq_audit_orders, seq_audit_order_items, seq_audit_payments;

-- Core Schema (Normalized)

-- Customers
CREATE TABLE customers (
  customer_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        VARCHAR(100) NOT NULL,
  email       VARCHAR(150) UNIQUE NOT NULL,
  created_at  TIMESTAMP DEFAULT NOW()
);

-- Products
CREATE TABLE products (
  product_id   INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         VARCHAR(120) NOT NULL,
  price        NUMERIC(10,2)  NOT NULL CHECK (price >= 0),
  active_flag  CHAR(1) DEFAULT 'Y' CHECK (active_flag IN ('Y','N')),
  created_at   TIMESTAMP DEFAULT NOW()
);

-- Orders (header)
CREATE TABLE orders (
  order_id     INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id  INTEGER NOT NULL REFERENCES customers(customer_id),
  order_date   DATE   DEFAULT CURRENT_DATE,
  status       VARCHAR(20) DEFAULT 'CREATED' CHECK (status IN ('CREATED','PAID','SHIPPED','CANCELLED','REFUNDED')),
  total_amount NUMERIC(12,2) DEFAULT 0 CHECK (total_amount >= 0)
);

-- Order Items (detail)
CREATE TABLE order_items (
  order_id    INTEGER NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
  product_id  INTEGER NOT NULL REFERENCES products(product_id),
  quantity    NUMERIC(10,2) NOT NULL CHECK (quantity > 0),
  unit_price  NUMERIC(10,2) NOT NULL CHECK (unit_price >= 0),
  line_total  NUMERIC(12,2) GENERATED ALWAYS AS (quantity * unit_price) STORED,
  CONSTRAINT pk_order_items PRIMARY KEY (order_id, product_id)
);

-- Payments
CREATE TABLE payments (
  payment_id  INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id    INTEGER NOT NULL REFERENCES orders(order_id),
  amount      NUMERIC(12,2) NOT NULL CHECK (amount > 0),
  payment_date DATE DEFAULT CURRENT_DATE,
  method      VARCHAR(20) CHECK (method IN ('CARD','CASH','BKASH','NAGAD','BANK')),
  status      VARCHAR(20) DEFAULT 'CAPTURED' CHECK (status IN ('CAPTURED','VOID','REFUNDED'))
);

-- Helpful index for order totals
CREATE INDEX ix_order_items_order ON order_items(order_id);

-- Audit/Provenance Tables

-- Common sequences
CREATE SEQUENCE seq_audit_products START WITH 10001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_orders   START WITH 20001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_order_items    START WITH 30001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_payments START WITH 40001 INCREMENT BY 1;

-- Products provenance
CREATE TABLE audit_products (
  audit_id      INTEGER PRIMARY KEY,
  product_id    INTEGER,
  operation     VARCHAR(10),  -- INSERT/UPDATE/DELETE
  old_name      VARCHAR(120),
  new_name      VARCHAR(120),
  old_price     NUMERIC(10,2),
  new_price     NUMERIC(10,2),
  old_active    CHAR(1),
  new_active    CHAR(1),
  actor         VARCHAR(128),
  operation_time TIMESTAMP DEFAULT NOW()
);

-- Orders provenance
CREATE TABLE audit_orders (
  audit_id      INTEGER PRIMARY KEY,
  order_id      INTEGER,
  operation     VARCHAR(10),
  old_status    VARCHAR(20),
  new_status    VARCHAR(20),
  old_total     NUMERIC(12,2),
  new_total     NUMERIC(12,2),
  actor         VARCHAR(128),
  operation_time TIMESTAMP DEFAULT NOW()
);

-- Order items provenance
CREATE TABLE audit_order_items (
  audit_id      INTEGER PRIMARY KEY,
  order_id      INTEGER,
  product_id    INTEGER,
  operation     VARCHAR(10),
  old_quantity  NUMERIC(10,2),
  new_quantity  NUMERIC(10,2),
  old_price     NUMERIC(10,2),
  new_price     NUMERIC(10,2),
  actor         VARCHAR(128),
  operation_time TIMESTAMP DEFAULT NOW()
);

-- Payments provenance
CREATE TABLE audit_payments (
  audit_id      INTEGER PRIMARY KEY,
  payment_id    INTEGER,
  order_id      INTEGER,
  operation     VARCHAR(10),
  old_status    VARCHAR(20),
  new_status    VARCHAR(20),
  old_amount    NUMERIC(12,2),
  new_amount    NUMERIC(12,2),
  actor         VARCHAR(128),
  operation_time TIMESTAMP DEFAULT NOW()
);

-- Helper: Maintain Orders.total_amount
CREATE OR REPLACE FUNCTION recompute_order_total(p_order_id INTEGER)
RETURNS VOID AS $$
BEGIN
  UPDATE orders o
     SET total_amount = COALESCE((SELECT SUM(line_total) FROM order_items WHERE order_id = p_order_id), 0)
   WHERE o.order_id = p_order_id;
END;
$$ LANGUAGE plpgsql;

-- Triggers to Capture Provenance

-- Products trigger function
CREATE OR REPLACE FUNCTION func_audit_products() RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    INSERT INTO audit_products(audit_id, product_id, operation, new_name, new_price, new_active, actor)
    VALUES (nextval('seq_audit_products'), NEW.product_id, 'INSERT', NEW.name, NEW.price, NEW.active_flag, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN
    INSERT INTO audit_products(audit_id, product_id, operation, old_name, new_name, old_price, new_price, old_active, new_active, actor)
    VALUES (nextval('seq_audit_products'), OLD.product_id, 'UPDATE', OLD.name, NEW.name, OLD.price, NEW.price, OLD.active_flag, NEW.active_flag, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    INSERT INTO audit_products(audit_id, product_id, operation, old_name, old_price, old_active, actor)
    VALUES (nextval('seq_audit_products'), OLD.product_id, 'DELETE', OLD.name, OLD.price, OLD.active_flag, CURRENT_USER);
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_products
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW EXECUTE FUNCTION func_audit_products();

-- Orders trigger function
CREATE OR REPLACE FUNCTION func_audit_orders() RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, new_status, new_total, actor)
    VALUES (nextval('seq_audit_orders'), NEW.order_id, 'INSERT', NEW.status, NEW.total_amount, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, old_status, new_status, old_total, new_total, actor)
    VALUES (nextval('seq_audit_orders'), OLD.order_id, 'UPDATE', OLD.status, NEW.status, OLD.total_amount, NEW.total_amount, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, old_status, old_total, actor)
    VALUES (nextval('seq_audit_orders'), OLD.order_id, 'DELETE', OLD.status, OLD.total_amount, CURRENT_USER);
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_orders
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW EXECUTE FUNCTION func_audit_orders();

-- Order Items trigger function
CREATE OR REPLACE FUNCTION func_audit_order_items() RETURNS TRIGGER AS $$
DECLARE
  v_order_id INTEGER;
BEGIN
  IF (TG_OP = 'INSERT') THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation, new_quantity, new_price, actor)
    VALUES (nextval('seq_audit_order_items'), NEW.order_id, NEW.product_id, 'INSERT', NEW.quantity, NEW.unit_price, CURRENT_USER);
    v_order_id := NEW.order_id;
    RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation, old_quantity, new_quantity, old_price, new_price, actor)
    VALUES (nextval('seq_audit_order_items'), OLD.order_id, OLD.product_id, 'UPDATE', OLD.quantity, NEW.quantity, OLD.unit_price, NEW.unit_price, CURRENT_USER);
    v_order_id := NEW.order_id;
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation, old_quantity, old_price, actor)
    VALUES (nextval('seq_audit_order_items'), OLD.order_id, OLD.product_id, 'DELETE', OLD.quantity, OLD.unit_price, CURRENT_USER);
    v_order_id := OLD.order_id;
    RETURN OLD;
  END IF;

  -- Recompute total after change. Note: This is simplified.
  -- In a real-world scenario with high concurrency, this could be handled by a separate process.
  PERFORM recompute_order_total(v_order_id);
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_order_items
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW EXECUTE FUNCTION func_audit_order_items();

-- Payments trigger function
CREATE OR REPLACE FUNCTION func_audit_payments() RETURNS TRIGGER AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, new_status, new_amount, actor)
    VALUES (nextval('seq_audit_payments'), NEW.payment_id, NEW.order_id, 'INSERT', NEW.status, NEW.amount, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'UPDATE') THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, old_status, new_status, old_amount, new_amount, actor)
    VALUES (nextval('seq_audit_payments'), OLD.payment_id, OLD.order_id, 'UPDATE', OLD.status, NEW.status, OLD.amount, NEW.amount, CURRENT_USER);
    RETURN NEW;
  ELSIF (TG_OP = 'DELETE') THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, old_status, old_amount, actor)
    VALUES (nextval('seq_audit_payments'), OLD.payment_id, OLD.order_id, 'DELETE', OLD.status, OLD.amount, CURRENT_USER);
    RETURN OLD;
  END IF;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trg_audit_payments
AFTER INSERT OR UPDATE OR DELETE ON payments
FOR EACH ROW EXECUTE FUNCTION func_audit_payments();


-- Sample Data and Activity
INSERT INTO customers(name,email) VALUES ('Alice','alice@example.com');
INSERT INTO customers(name,email) VALUES ('Bob','bob@example.com');

INSERT INTO products(name, price) VALUES ('Laptop', 1000);
INSERT INTO products(name, price) VALUES ('Tablet', 500);
INSERT INTO products(name, price) VALUES ('Headphones', 150);

UPDATE products SET price = 1099.99 WHERE name = 'Laptop';
UPDATE products SET active_flag = 'N' WHERE name = 'Tablet';

-- Orders and items
DO $$
DECLARE
  v_order_id orders.order_id%TYPE;
BEGIN
  INSERT INTO orders(customer_id, status) VALUES (1, 'CREATED')
  RETURNING order_id INTO v_order_id;

  INSERT INTO order_items(order_id, product_id, quantity, unit_price)
  VALUES (v_order_id, 1, 1, 1099.99);

  INSERT INTO order_items(order_id, product_id, quantity, unit_price)
  VALUES (v_order_id, 3, 2, 150);

  UPDATE order_items SET quantity = 3 WHERE order_id = v_order_id AND product_id = 3;

  INSERT INTO payments(order_id, amount, method, status)
  VALUES (v_order_id, 1549.99, 'CARD', 'CAPTURED');

  PERFORM recompute_order_total(v_order_id);

  UPDATE orders SET status = 'PAID' WHERE order_id = v_order_id;
  UPDATE orders SET status = 'SHIPPED' WHERE order_id = v_order_id;
END;
$$;

COMMIT;
