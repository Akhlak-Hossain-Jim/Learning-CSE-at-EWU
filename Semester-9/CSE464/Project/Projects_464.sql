--Housekeeping

BEGIN
  EXECUTE IMMEDIATE 'DROP VIEW v_order_latest_status';
EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN
  FOR t IN (SELECT table_name FROM user_tables WHERE table_name IN
            ('CUSTOMERS','PRODUCTS','ORDERS','ORDER_ITEMS','PAYMENTS',
             'AUDIT_PRODUCTS','AUDIT_ORDERS','AUDIT_ORDER_ITEMS','AUDIT_PAYMENTS')) LOOP
    EXECUTE IMMEDIATE 'DROP TABLE '||t.table_name||' CASCADE CONSTRAINTS PURGE';
  END LOOP;
END;
/
BEGIN
  FOR s IN (SELECT sequence_name FROM user_sequences WHERE sequence_name LIKE 'SEQ_%') LOOP
    EXECUTE IMMEDIATE 'DROP SEQUENCE '||s.sequence_name;
  END LOOP;
END;
/

-- Core Schema (Normalized)

-- Customers
CREATE TABLE customers (
  customer_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name        VARCHAR2(100) NOT NULL,
  email       VARCHAR2(150) UNIQUE NOT NULL,
  created_at  TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Products
CREATE TABLE products (
  product_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name         VARCHAR2(120) NOT NULL,
  price        NUMBER(10,2)  NOT NULL CHECK (price >= 0),
  active_flag  CHAR(1) DEFAULT 'Y' CHECK (active_flag IN ('Y','N')),
  created_at   TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Orders (header)
CREATE TABLE orders (
  order_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  customer_id  NUMBER NOT NULL REFERENCES customers(customer_id),
  order_date   DATE   DEFAULT TRUNC(SYSDATE),
  status       VARCHAR2(20) DEFAULT 'CREATED' CHECK (status IN ('CREATED','PAID','SHIPPED','CANCELLED','REFUNDED')),
  total_amount NUMBER(12,2) DEFAULT 0 CHECK (total_amount >= 0)
);

-- Order Items (detail)
CREATE TABLE order_items (
  order_id    NUMBER NOT NULL REFERENCES orders(order_id) ON DELETE CASCADE,
  product_id  NUMBER NOT NULL REFERENCES products(product_id),
  quantity    NUMBER(10,2) NOT NULL CHECK (quantity > 0),
  unit_price  NUMBER(10,2) NOT NULL CHECK (unit_price >= 0),
  line_total  GENERATED ALWAYS AS (quantity * unit_price) VIRTUAL,
  CONSTRAINT pk_order_items PRIMARY KEY (order_id, product_id)
);

-- Payments
CREATE TABLE payments (
  payment_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  order_id    NUMBER NOT NULL REFERENCES orders(order_id),
  amount      NUMBER(12,2) NOT NULL CHECK (amount > 0),
  payment_date DATE DEFAULT TRUNC(SYSDATE),
  method      VARCHAR2(20) CHECK (method IN ('CARD','CASH','BKASH','NAGAD','BANK')),
  status      VARCHAR2(20) DEFAULT 'CAPTURED' CHECK (status IN ('CAPTURED','VOID','REFUNDED'))
);

-- Helpful index for order totals
CREATE INDEX ix_order_items_order ON order_items(order_id);

--Audit/Provenance Tables

-- Common sequences
CREATE SEQUENCE seq_audit_products START WITH 10001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_orders   START WITH 20001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_order_items    START WITH 30001 INCREMENT BY 1;
CREATE SEQUENCE seq_audit_payments START WITH 40001 INCREMENT BY 1;

-- Products provenance
CREATE TABLE audit_products (
  audit_id      NUMBER PRIMARY KEY,
  product_id    NUMBER,
  operation     VARCHAR2(10),  -- INSERT/UPDATE/DELETE
  old_name      VARCHAR2(120),
  new_name      VARCHAR2(120),
  old_price     NUMBER(10,2),
  new_price     NUMBER(10,2),
  old_active    CHAR(1),
  new_active    CHAR(1),
  actor         VARCHAR2(128),
  client_ip     VARCHAR2(64),
  module        VARCHAR2(64),
  operation_time TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Orders provenance
CREATE TABLE audit_orders (
  audit_id      NUMBER PRIMARY KEY,
  order_id      NUMBER,
  operation     VARCHAR2(10),
  old_status    VARCHAR2(20),
  new_status    VARCHAR2(20),
  old_total     NUMBER(12,2),
  new_total     NUMBER(12,2),
  actor         VARCHAR2(128),
  client_ip     VARCHAR2(64),
  module        VARCHAR2(64),
  operation_time TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Order items provenance
CREATE TABLE audit_order_items (
  audit_id      NUMBER PRIMARY KEY,
  order_id      NUMBER,
  product_id    NUMBER,
  operation     VARCHAR2(10),
  old_quantity  NUMBER(10,2),
  new_quantity  NUMBER(10,2),
  old_price     NUMBER(10,2),
  new_price     NUMBER(10,2),
  actor         VARCHAR2(128),
  client_ip     VARCHAR2(64),
  module        VARCHAR2(64),
  operation_time TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- Payments provenance
CREATE TABLE audit_payments (
  audit_id      NUMBER PRIMARY KEY,
  payment_id    NUMBER,
  order_id      NUMBER,
  operation     VARCHAR2(10),
  old_status    VARCHAR2(20),
  new_status    VARCHAR2(20),
  old_amount    NUMBER(12,2),
  new_amount    NUMBER(12,2),
  actor         VARCHAR2(128),
  client_ip     VARCHAR2(64),
  module        VARCHAR2(64),
  operation_time TIMESTAMP DEFAULT SYSTIMESTAMP
);

--Helper: Maintain Orders.total_amount
CREATE OR REPLACE PROCEDURE recompute_order_total(p_order_id IN NUMBER) AS
BEGIN
  UPDATE orders o
     SET o.total_amount = NVL( (SELECT SUM(line_total) FROM order_items WHERE order_id = p_order_id), 0)
   WHERE o.order_id = p_order_id;
END;
/

--Triggers to Capture Provenance

-- Products trigger
CREATE OR REPLACE TRIGGER trg_audit_products
AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW
DECLARE
  v_actor  VARCHAR2(128) := USER;
  v_ip     VARCHAR2(64)  := SYS_CONTEXT('USERENV','IP_ADDRESS');
  v_module VARCHAR2(64)  := SYS_CONTEXT('USERENV','MODULE');
BEGIN
  IF INSERTING THEN
    INSERT INTO audit_products(
      audit_id, product_id, operation,
      new_name, new_price, new_active,
      actor, client_ip, module
    ) VALUES (
      seq_audit_products.NEXTVAL, :NEW.product_id, 'INSERT',
      :NEW.name, :NEW.price, :NEW.active_flag,
      v_actor, v_ip, v_module
    );
  ELSIF UPDATING THEN
    INSERT INTO audit_products(
      audit_id, product_id, operation,
      old_name, new_name, old_price, new_price,
      old_active, new_active,
      actor, client_ip, module
    ) VALUES (
      seq_audit_products.NEXTVAL, :OLD.product_id, 'UPDATE',
      :OLD.name, :NEW.name, :OLD.price, :NEW.price,
      :OLD.active_flag, :NEW.active_flag,
      v_actor, v_ip, v_module
    );
  ELSIF DELETING THEN
    INSERT INTO audit_products(
      audit_id, product_id, operation,
      old_name, old_price, old_active,
      actor, client_ip, module
    ) VALUES (
      seq_audit_products.NEXTVAL, :OLD.product_id, 'DELETE',
      :OLD.name, :OLD.price, :OLD.active_flag,
      v_actor, v_ip, v_module
    );
  END IF;
END;
/

-- Orders trigger
CREATE OR REPLACE TRIGGER trg_audit_orders
AFTER INSERT OR UPDATE OR DELETE ON orders
FOR EACH ROW
DECLARE
  v_actor  VARCHAR2(128) := USER;
  v_ip     VARCHAR2(64)  := SYS_CONTEXT('USERENV','IP_ADDRESS');
  v_module VARCHAR2(64)  := SYS_CONTEXT('USERENV','MODULE');
BEGIN
  IF INSERTING THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, new_status, new_total, actor, client_ip, module)
    VALUES (seq_audit_orders.NEXTVAL, :NEW.order_id, 'INSERT', :NEW.status, :NEW.total_amount, v_actor, v_ip, v_module);
  ELSIF UPDATING THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, old_status, new_status, old_total, new_total, actor, client_ip, module)
    VALUES (seq_audit_orders.NEXTVAL, :OLD.order_id, 'UPDATE', :OLD.status, :NEW.status, :OLD.total_amount, :NEW.total_amount, v_actor, v_ip, v_module);
  ELSIF DELETING THEN
    INSERT INTO audit_orders(audit_id, order_id, operation, old_status, old_total, actor, client_ip, module)
    VALUES (seq_audit_orders.NEXTVAL, :OLD.order_id, 'DELETE', :OLD.status, :OLD.total_amount, v_actor, v_ip, v_module);
  END IF;
END;
/

-- Order Items trigger: audit and maintain order total after change
CREATE OR REPLACE TRIGGER trg_audit_order_items
AFTER INSERT OR UPDATE OR DELETE ON order_items
FOR EACH ROW
DECLARE
  v_order_id NUMBER;
  v_actor  VARCHAR2(128) := USER;
  v_ip     VARCHAR2(64)  := SYS_CONTEXT('USERENV','IP_ADDRESS');
  v_module VARCHAR2(64)  := SYS_CONTEXT('USERENV','MODULE');
BEGIN
  IF INSERTING THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation,
                                  new_quantity, new_price, actor, client_ip, module)
    VALUES (seq_audit_order_items.NEXTVAL, :NEW.order_id, :NEW.product_id, 'INSERT',
            :NEW.quantity, :NEW.unit_price, v_actor, v_ip, v_module);
    v_order_id := :NEW.order_id;

  ELSIF UPDATING THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation,
                                  old_quantity, new_quantity, old_price, new_price,
                                  actor, client_ip, module)
    VALUES (seq_audit_order_items.NEXTVAL, :OLD.order_id, :OLD.product_id, 'UPDATE',
            :OLD.quantity, :NEW.quantity, :OLD.unit_price, :NEW.unit_price,
            v_actor, v_ip, v_module);
    v_order_id := :NEW.order_id;

  ELSIF DELETING THEN
    INSERT INTO audit_order_items(audit_id, order_id, product_id, operation,
                                  old_quantity, old_price, actor, client_ip, module)
    VALUES (seq_audit_order_items.NEXTVAL, :OLD.order_id, :OLD.product_id, 'DELETE',
            :OLD.quantity, :OLD.unit_price, v_actor, v_ip, v_module);
    v_order_id := :OLD.order_id;
  END IF;

  -- The recomputation of the order total has been moved to a separate step
  -- to avoid the mutating table error (ORA-04091).
  NULL;
END;
/

-- Payments trigger
CREATE OR REPLACE TRIGGER trg_audit_payments
AFTER INSERT OR UPDATE OR DELETE ON payments
FOR EACH ROW
DECLARE
  v_actor  VARCHAR2(128) := USER;
  v_ip     VARCHAR2(64)  := SYS_CONTEXT('USERENV','IP_ADDRESS');
  v_module VARCHAR2(64)  := SYS_CONTEXT('USERENV','MODULE');
BEGIN
  IF INSERTING THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, new_status, new_amount, actor, client_ip, module)
    VALUES (seq_audit_payments.NEXTVAL, :NEW.payment_id, :NEW.order_id, 'INSERT', :NEW.status, :NEW.amount, v_actor, v_ip, v_module);
  ELSIF UPDATING THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, old_status, new_status, old_amount, new_amount, actor, client_ip, module)
    VALUES (seq_audit_payments.NEXTVAL, :OLD.payment_id, :OLD.order_id, 'UPDATE', :OLD.status, :NEW.status, :OLD.amount, :NEW.amount, v_actor, v_ip, v_module);
  ELSIF DELETING THEN
    INSERT INTO audit_payments(audit_id, payment_id, order_id, operation, old_status, old_amount, actor, client_ip, module)
    VALUES (seq_audit_payments.NEXTVAL, :OLD.payment_id, :OLD.order_id, 'DELETE', :OLD.status, :OLD.amount, v_actor, v_ip, v_module);
  END IF;
END;
/

--Sample Data and Activity
-- Customers
INSERT INTO customers(name,email) VALUES ('Alice','alice@example.com');
INSERT INTO customers(name,email) VALUES ('Bob','bob@example.com');

-- Products
INSERT INTO products(name, price) VALUES ('Laptop', 1000);
INSERT INTO products(name, price) VALUES ('Tablet', 500);
INSERT INTO products(name, price) VALUES ('Headphones', 150);

-- Price change and deactivation to generate provenance
UPDATE products SET price = 1099.99 WHERE name = 'Laptop';
UPDATE products SET active_flag = 'N' WHERE name = 'Tablet';

-- Orders and items
-- Use a single PL/SQL block to ensure atomicity and handle the generated ID
BEGIN
  DECLARE
    v_order_id orders.order_id%TYPE;
  BEGIN
    -- Insert the order and capture the generated ID
    INSERT INTO orders(customer_id, status) VALUES (1, 'CREATED')
    RETURNING order_id INTO v_order_id;

    -- Use the captured order ID for all subsequent related records
    INSERT INTO order_items(order_id, product_id, quantity, unit_price)
    VALUES (v_order_id, 1, 1, 1099.99);  -- Laptop line

    INSERT INTO order_items(order_id, product_id, quantity, unit_price)
    VALUES (v_order_id, 3, 2, 150);      -- 2x Headphones

    -- Update an item quantity
    UPDATE order_items SET quantity = 3 WHERE order_id = v_order_id AND product_id = 3;

    -- Payment
    -- The order total is recomputed by a trigger, but we need the correct amount for the payment record itself.
    INSERT INTO payments(order_id, amount, method, status)
    VALUES (v_order_id, 1549.99, 'CARD', 'CAPTURED'); -- Corrected total: 1099.99 + (3 * 150) = 1549.99

    -- Manually recompute the order total after all items have been changed
    recompute_order_total(v_order_id);

    -- Order status changes
    UPDATE orders SET status = 'PAID' WHERE order_id = v_order_id;
    UPDATE orders SET status = 'SHIPPED' WHERE order_id = v_order_id;
  END;
END;
/

COMMIT;

--Quick Checks

SELECT * FROM orders;
SELECT * FROM order_items WHERE order_id = 1;
SELECT * FROM products;
SELECT * FROM payments;

--Provenance Queries (Why / Where / How)

--Why-provenance: Why is order 1 total the current value?
   -- Decompose total into contributing line totals (justification)
SELECT oi.product_id, p.name, oi.quantity, oi.unit_price, oi.line_total
FROM order_items oi
JOIN products p ON p.product_id = oi.product_id
WHERE oi.order_id = 1;
-- Interpret: The order total equals SUM(line_total) for these rows.

--Where-provenance: From which rows did the current Laptop price originate?

-- Show evolution of price for "Laptop"
SELECT ap.operation_time, ap.operation, ap.old_price, ap.new_price, ap.actor
FROM audit_products ap
JOIN products p ON p.product_id = ap.product_id
WHERE p.name = 'Laptop'
ORDER BY ap.operation_time;

--How-provenance: How did order 1â€™s status evolve?

SELECT ao.operation_time, ao.operation, ao.old_status, ao.new_status, ao.actor
FROM audit_orders ao
WHERE ao.order_id = 1
ORDER BY ao.operation_time;

--Where-provenance: Find all actions by a given user on Orders.

SELECT ao.actor, ao.operation, ao.order_id, ao.operation_time, ao.old_status, ao.new_status
FROM audit_orders ao
WHERE ao.actor = USER
ORDER BY ao.operation_time;

--Why-provenance: Why does order 1 have 3 Headphones?

-- Show item change history for that line
SELECT aoi.operation_time, aoi.operation, aoi.old_quantity, aoi.new_quantity, aoi.actor
FROM audit_order_items aoi
WHERE aoi.order_id = 1 AND aoi.product_id = 3
ORDER BY aoi.operation_time;

--Where-provenance: Trace the source insert for product Tablet

SELECT ap.actor, ap.operation_time
FROM audit_products ap
JOIN products p ON p.product_id = ap.product_id
WHERE p.name = 'Tablet' AND ap.operation = 'INSERT';

--How-provenance: Show payments lifecycle for order 1.

SELECT apy.operation_time, apy.operation, apy.old_status, apy.new_status, apy.old_amount, apy.new_amount
FROM audit_payments apy
WHERE apy.order_id = 1
ORDER BY apy.operation_time;

--Why-provenance: Why is order 1 status SHIPPED now?

-- Show the last status-changing UPDATE on the order
SELECT *
FROM audit_orders ao
WHERE ao.order_id = 1
  AND ao.operation = 'UPDATE'
ORDER BY ao.operation_time DESC
FETCH FIRST 1 ROWS ONLY;

--Where-provenance: Retrieve original values before any updates for product Laptop.

-- First INSERT record contains initial values
SELECT operation_time, old_name, new_name, old_price, new_price
FROM audit_products
WHERE product_id = (SELECT product_id FROM products WHERE name = 'Laptop')
  AND operation = 'INSERT';

--How-provenance: Full change history for any deleted product (if any later).

SELECT *
FROM audit_products
WHERE operation = 'DELETE'
ORDER BY operation_time;

--Bonus Why/How: Show how order 1 total changed over time due to item edits.

SELECT ao.operation_time, ao.operation, ao.old_total, ao.new_total
FROM audit_orders ao
WHERE ao.order_id = 1 AND ao.operation IN ('INSERT','UPDATE')
ORDER BY ao.operation_time;

--Convenience View: Current order with latest audit snapshot

CREATE OR REPLACE VIEW v_order_latest_status AS
SELECT o.order_id, o.customer_id, o.order_date, o.status, o.total_amount,
       ao.operation_time AS latest_audit_time, ao.operation AS latest_operation
FROM orders o
LEFT JOIN (
  SELECT order_id, MAX(operation_time) AS latest_time
  FROM audit_orders
  GROUP BY order_id
) last ON o.order_id = last.order_id
LEFT JOIN audit_orders ao
  ON ao.order_id = last.order_id AND ao.operation_time = last.latest_time;

SELECT * FROM v_order_latest_status WHERE order_id = 1;


--Optional: Flashback Query Demo (if UNDO allows)

-- See row as of 5 minutes ago (adjust interval if needed)
SELECT name, price
FROM products
AS OF TIMESTAMP (SYSTIMESTAMP - INTERVAL '5' MINUTE)
WHERE name = 'Laptop';

-- Reverse Queries (Trace Back to Sources)
---Original price and name of a product currently priced at 1099.99:

SELECT ap.old_name, ap.old_price
FROM audit_products ap
WHERE ap.product_id = (SELECT product_id FROM products WHERE price = 1099.99 AND name = 'Laptop')
  AND ap.operation = 'UPDATE'
ORDER BY ap.operation_time
FETCH FIRST 1 ROWS ONLY;

---Who first inserted order 1?

SELECT actor, operation_time
FROM audit_orders
WHERE order_id = 1 AND operation = 'INSERT';

---Complete change history for a deleted product (Tablet if deleted later):

SELECT *
FROM audit_products
WHERE product_id = (SELECT product_id FROM products WHERE name = 'Tablet')
ORDER BY operation_time;